---
title: 알고리즘 4 <br/> ( 자료구조 )
layout: post
summary: 백준 알고리즘을 풀면서 좋은 코드 비교 
categories: 
    - algorithm
    - JAVA
tags: 
   - difficulty-low: "난이도 중"
thumbnail: posts/icon-algorithm.png
pre: "/algorithm/javascript/2019/06/29/algorithm-3.html"
nex: ""
---
##### 풀어보기 : <a href="https://www.acmicpc.net/problem/tag/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0" target="_blank"> 백준 알고리즘(자료구조편)</a> 

<br/>
###### 해당 문제 풀이 : <a href="https://www.acmicpc.net/problem/7785" target="_blank"> 회사에 있는 사람 </a> 

<p class="text-danger bold-text">Map Key를 ArratList에 담기 </p>
 - 내 풀이 
<pre>
{% raw %}
Iterator iterator = employName.keySet().iterator(); 
while(iterator.hasNext()){ 
    String name = (String) iterator.next(); 
    emmployNameSort.add(name); 
}

{% endraw %}
</pre>
 - 좋은 방법
<pre>
{% raw %}
emmployNameSort = new ArrayList&lt;String>(employName.keySet());
{% endraw %}
</pre>

<p class="text-danger bold-text">HashMap 역순 정렬</p>
 - Collections.reverse()는 제대로된 역순 정렬이 되지 않아 아래 방법으로 해결
<pre>
{% raw %}
 Collections.sort(emmployNameSort,Collections.reverseOrder());
{% endraw %}
</pre>

<p class="bold-text"><a href="https://github.com/7271kim/Single_JAVA_Project/blob/master/src/algorithm/dataStructure/HowManyPeopleInMyCompany.java" target="_blank">전체 코드 보기</a></p>
<br/>
<br/>

###### 해당 문제 풀이 : <a href="https://www.acmicpc.net/problem/9375" target="_blank"> 패션왕 신해빈 </a> 
<p class="text-danger bold-text">HashMap 전체출력 간편한 코드</p>
<pre>
{% raw %}
for( String key : totalCase.keySet() ){
    result *= ( totalCase.get(key).size() +1);
}
{% endraw %}
</pre>

<p class="bold-text"><a href="https://github.com/7271kim/Single_JAVA_Project/blob/master/src/algorithm/dataStructure/HowManyGetMyClose.java" target="_blank">전체 코드 보기</a></p>
<br/>
<br/>


###### 해당 문제 풀이 : <a href="https://www.acmicpc.net/problem/1620" target="_blank"> 나는야 포켓몬 마스터 이다솜 </a> 
<p class="text-danger bold-text">HashMap, ArrayList 두가지 방법이 아니 HashMap만 사용해서 풀 수 있는 경우. </p>
<pre>
{% raw %}
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
ArrayList&lt;String> pocketMonData         = new ArrayList&lt;String>();
pocketMonData.add("");
Map&lt;String, Integer> pocketMonDataMap   = new HashMap&lt;String, Integer>(); 
try {
    String [] inputFirst        = br.readLine().split(" ");
    int pocketMonsterCount      = Integer.parseInt(inputFirst[0]);
    int questionCount           = Integer.parseInt(inputFirst[1]);
    for ( int index = 0; index &lt; pocketMonsterCount; index++ ) {
        String data = br.readLine();
        pocketMonData.add(data);
        pocketMonDataMap.put(data, index+1);
    }
    for ( int index = 0; index &lt; questionCount; index++) {
        String question = br.readLine();
        if(Pattern.matches("^[0-9]*$", question)) {
            System.out.println(pocketMonData.get(Integer.parseInt(question)));
        } else {
            System.out.println( pocketMonDataMap.get(question) );
        }
    }
} catch (Exception e) {

}
{% endraw %}
</pre>
 - 생각을 바꿔서 HashMap으로만 한다면!? >> 발상의 전환

<pre>
{% raw %}
Scanner sc = new Scanner(System.in);
HashMap&lt;String, String> map = new HashMap&lt;>();

int n = sc.nextInt();
int m = sc.nextInt();

for(int i=1;i&lt;=n;i++) {
    String s = sc.next();
    map.put(s, Integer.toString(i));
    map.put(Integer.toString(i),s);
}
for(int i=0;i&lt;m;i++) {
    String s = sc.next();
    System.out.println(map.get(s));
}
{% endraw %}
</pre>


<p class="bold-text"><a href="https://github.com/7271kim/Single_JAVA_Project/blob/master/src/algorithm/dataStructure/Pocketmon.java" target="_blank">전체 코드 보기</a></p>
<br/>
<br/>

###### 해당 문제 풀이 : <a href="https://www.acmicpc.net/problem/5639" target="_blank"> 이진 검색 트리 </a> 
<p class="text-danger bold-text"> 왜 2진트리가 자료구조에 속하는지 정확한 개념이 없었음</p>
<p class="text-danger bold-text"> 결론은 조건에 따라 2진트리의 자료구조를 내가 만드는 것 </p>

 - 1차 : 알고리즘을 위해 회귀를 사용하지 않고 1개일때를 전제로 작성
<pre>
{% raw %}
class BinaryTree {
    int node;
    BinaryTree left;
    BinaryTree right;
    
    public BinaryTree( int node ) {
        this.node   = node;
        this.left  = null;
        this.right  = null;
    }
   
     public BinaryTree addTree ( BinaryTree orignalTree, int value ) {
        BinaryTree tempBinaryTree = new BinaryTree(value);
        if( value &lt; orignalTree.node ) {
            orignalTree.lefet = tempBinaryTree;
        } else if( value > orignalTree.node ) {
            orignalTree.right = tempBinaryTree;
        }
        return orignalTree;
    }
    
}

{% endraw %}
</pre>

 - 2차 : 달려야 하는 것은 무엇인가 ? 반복되어야 하는것은 무엇인가?
 - 왼쪽 오른쪽은 트리데이터가 달릴수 있다.
 - 반복은 좌우에 단다.

<pre>
{% raw %}
public BinaryTree addTree ( BinaryTree orignalTree, int value ) {
    if( orignalTree == null ) return new BinaryTree(value);
    if( value &lt; orignalTree.node ) {
        orignalTree.left = addTree(orignalTree.left, value);
    } else if( value > orignalTree.node ) {
        orignalTree.right = addTree(orignalTree.right,value);
    }
    return orignalTree;
}
{% endraw %}
</pre>

<p class="bold-text"><a href="https://github.com/7271kim/Single_JAVA_Project/blob/master/src/algorithm/dataStructure/GetBinaryTree.java" target="_blank">전체 코드 보기</a></p>
<br/>
<br/>

###### 해당 문제 풀이 : <a href="https://www.acmicpc.net/problem/7453" target="_blank">합이 0인 네 정수 </a> 
<p class="bold-text">1. 시간 복잡도</p>
 - O(1) : 입력되는 N과 상관없이 일정한 시행시간을 가진다.
 - O(logN) : 자료가 증가함에 따라 수렴 , 2진 검색
 - O(N) : 정비례 , 선형
 - O(N^2) : 따따블  - for문에 for문 
 - O(NlogN) : N배가 많아지면 N배보다 조금 증가 , 커다란 문제를 독립문제로 쪼개고 다시 하나로 모으는 경우
>> 해당 문제를 전체 탐색으로 풀 경우 총 개수가 4000개로 O(N^4) 즉 4경이 넘어버려 전체탐색은 맞지 않는다.

<p class="text-danger bold-text">Merg : 합치기 - 2개의 그룹을 하나로 묶어 두 그룹의 합이 0인 것을 찾는다.</p>
<pre>
{% raw %}
// 로직은 맞지만 너무 많은 메모리릴 사용한다고 ;;;;; 메모리 초가가 남.
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int totalRow =  Integer.parseInt(br.readLine());
ArrayList&lt;Integer> firstIndex = new ArrayList&lt;Integer>();
ArrayList&lt;Integer> secondIndex = new ArrayList&lt;Integer>();
ArrayList&lt;Integer> thirdIndex = new ArrayList&lt;Integer>();
ArrayList&lt;Integer> fourIndex = new ArrayList&lt;Integer>();
for( int index = 0; index &lt; totalRow; index++ ) {
    String [] inputData  = br.readLine().split(" ");
     firstIndex.add(Integer.parseInt(inputData[0]));
     secondIndex.add(Integer.parseInt(inputData[1]));
     thirdIndex.add(Integer.parseInt(inputData[2]));
     fourIndex.add(Integer.parseInt(inputData[3]));
}
//1. 2개의 그룹으로 묶기  HashMap&lt; 숫자, 중복 갯수 > 로 담기
Map&lt;Integer, Integer> firstGroup = new HashMap&lt;Integer, Integer>();
Map&lt;Integer, Integer> secondGroup = new HashMap&lt;Integer, Integer>();

for( int firstData = 0; firstData &lt; totalRow; firstData++   ) {
    for( int secondData = 0; secondData &lt; totalRow; secondData++ ) {
        int totalSumFirstSecond    = firstIndex.get(firstData) + secondIndex.get(secondData);
        int totalSumThirdFour    = thirdIndex.get(firstData) +  fourIndex.get(secondData);
        
        if( firstGroup.containsKey( totalSumFirstSecond ) ) {
            firstGroup.replace(totalSumFirstSecond, firstGroup.get(totalSumFirstSecond)+1);
        } else {
            firstGroup.put(totalSumFirstSecond, 1);
        }
        if( secondGroup.containsKey( totalSumThirdFour ) ) {
            secondGroup.replace(totalSumThirdFour, secondGroup.get(totalSumThirdFour)+1);
        }else {
            secondGroup.put(totalSumThirdFour, 1);
        }
    }
}

// 찾기 
int sizeFisrt   = firstGroup.size();
int sizeSecond  = secondGroup.size();
int result      = 0;
Map&lt;Integer, Integer> loop;
Map&lt;Integer, Integer> seek;
if( sizeFisrt &lt; sizeSecond ) {
    loop = firstGroup;
    seek = secondGroup;
} else {
    loop = secondGroup;
    seek = firstGroup;
}
System.out.println(firstGroup);
System.out.println(secondGroup);

for( int key :  loop.keySet()) {
    int temt = -(key);
    if(seek.containsKey(temt)) {
        result += (loop.get(key) *seek.get(temt) );
    }
}
System.out.println(result);

// 같은 개념이지만 좀 더 깔끔하게 짠 남의 코드 
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
int[][] arr = new int[n][4];
long answer = 0;
Map<Integer,Integer> map = new HashMap<Integer,Integer>();
for(int i=0;i<n;i++)
    for(int j=0;j<4;j++)
        arr[i][j] = sc.nextInt();

for(int i=0;i<n;i++)
    for(int j=0;j<n;j++) {
        int tmp = arr[i][0] + arr[j][1];
        if(map.containsKey(tmp))
            map.replace(tmp, map.get(tmp)+1);
        else
            map.put(tmp, 1);
    }
for(int i=0;i<n;i++)
    for(int j=0;j<n;j++) {
        int tmp = (arr[i][2]+arr[j][3])*-1;
        if(map.containsKey(tmp)) //AB + CD == 0?
            answer += map.get(tmp);
    }
System.out.println(answer);

{% endraw %}
</pre>

<p class="bold-text"><a href="https://github.com/7271kim/Single_JAVA_Project/blob/master/src/algorithm/dataStructure/TimeComplexity.java" target="_blank">전체 코드 보기</a></p>

<br/><br/>
<p>** 번외</p>
<p class="text-danger bold-text">  내가 못하는 회귀함수 </p>
<pre>
{% raw %}
int result=0;
for(int first : total ) {
    for(int second : total) {
        for(int third : total) {
            for( int four : total ) {
                if(first+second+third+four == 0) result++;
            }
        }
    }
}
{% endraw %}
</pre>
<p>1. return 정하기 : int result</p>
<p>2. 반복되는 로직 찾기 : first+second+third+four ... 과 for문 => 부모것 + 자기것 합친것</p>
<p>3. 종료조건 : 4번째 턴에 종료</p>
<pre>
{% raw %}
public static void getResult( ArrayList&lt;Integer> total, int result, int parent, int index ){
    if( index == 4 && parent == 0 ) result++;
    if( index == 4 ) return result;
    
    index++;
    
     for( int data : total ) {
       int tempParent = parent + data;
        return getResult( total, tempParent, result, tempParent, index );
     }
     return result;
}
{% endraw %}
</pre>

<br/>
<br/>



